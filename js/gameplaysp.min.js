function play() {
    if(nothidden){hideghuti(2);hideghuti(4);}
 if (playbtn.innerText == "ROLE DICE") {
        setTimeout(afteranimation, 200);
        playbtn.style.backgroundColor = "white";
        playbtn.innerText = "Wait for a second";
        playbtn.style.color = turn;
        playbtn.disabled = true;
    }
}
function gamewin(ply) {
    let cnt = 0;
    for (let i = 1; i < 5; i++) {
        if (ghutipos[ply][i] == 24) cnt++;
    }
    if (cnt == 4) {
        updategreater4(13);
        pending = false;
        if(ply==1)
        {
       
            swal("Winner Winner Chicken Dinner","Congrats you won the game!!!","success");
            let lblink="https://chokosta.herokuapp.com/";
            location.assign(lblink);
        }
        else
        swal("Better luck next time","Well played try another new game ","error");
        return ply; 
        

    }
    return 0;
}

function afteranimation() {
    showdice();
    roleghuti();
    if(tut)
    swal("YOUR SCORE "+currentscore,"click on red ghuti to move that one","success");
    boxes = [];
    if (moveghutiIsPossible(playerid)) {
        pending = true;
       // console.log("trying",playerid);
        if(playerid==1)
        playbtn.innerText = "Click any " + playercolor[playerid] + " guthi you want to move";
        else{
            playbtn.innerText="Wait for Computer's move";
        }
        timeLeft = 30;
        playbtn.style.color = playercolor[playerid];
        playbtn.style.backgroundColor = "white";
        if(timerId!=0)
        {
            clearInterval(timerId);
            timerId=0;
        }
        timerId=setInterval(countdown,timeLeft);
    }
     
}
function movedone(movechange){

    if(timerId!=0)
    {
        clearInterval(timerId);
        timerId=0;
    }
    timerId=setInterval(countdown,timeLeft);
    hidedice();
    let s=new Set();
    for(let i=0;i<=25;i++)
    pos[i]=[];
    for(let i=1;i<4;i+=2){
        for(let j=1;j<=4;j++)
        {
            let gid='p'+i+'g'+j;
            let bxno=playermap[i][ghutipos[i][j]]
            s.add(bxno);
            pos[bxno].push(gid);
        }
    }
    function safeupdate(values)
    {   
        if (pos[values].length == 1) update1(values);
        else if (pos[values].length == 2) update2(values);
        else if (pos[values].length == 4 || pos[values].length == 3) update4(values);
        else if (pos[values].length >= 5) updategreater4(values);
        
    }
    s.forEach(safeupdate); 
    for (let i = 0; i < boxes.length; i++) {
        if (pos[boxes[i]].length == 1) update1(boxes[i]);
        else if (pos[boxes[i]].length == 2) update2(boxes[i]);
        else if (pos[boxes[i]].length == 4 || pos[boxes[i]].length == 3) update4(boxes[i]);
        else if (pos[boxes[i]].length >= 5) updategreater4(boxes[i]);
        
    }
    if(gamewin(nextplayer[move]))
    {
        if(gamewin(nextplayer[move])==1)

        return 0;
    }
    if(movechange){
        move++;
        move%=2;
    }
    else if(tut)
    swal("YOUR TURN","click on the role dice button to check score","success");
    pending=false;
    let x = nextplayer[move];
    playbtn.style.backgroundColor=playercolor[x];
    playbtn.style.color='white';
    playbtn.innerText="ROLE DICE";
    playbtn.disabled=false;
    if(compmode==true){
        playerid=nextplayer[move];
        if(move)
        {
            compplay(); 
        }
            
    }
    return  0;
}
function compplay(){
    showdice();
    afteranimation();
    if(tut)
    swal(currentscore+"",'computer score on this move',"info").then(()=>{
        setTimeout(compmove,1000);
    });
    else
    setTimeout(compmove,4000);
    
}
function compmove()
{
    let rghutimove = moveghutiIsPossible(playerid);
    let attackghutimv=compgoodmove(playerid);
    console.log("ghuti",attackghutimv);
    if(pending && rghutimove && attackghutimv ) moveghuti(playerid, attackghutimv);
    else if (pending && rghutimove) moveghuti(playerid, rghutimove);
    return 0;
}
function countdown() {
    try {
        if(tut && playerid==3 && prgwidth >= 5 )
    swal.close();
    } catch (error) {
       console.log(error) ;
    }
    
    if (prgwidth >= 99) {
        stopcountdown();
            let rghutimove = moveghutiIsPossible(playerid);
            if (pending && rghutimove) moveghuti(playerid, rghutimove);
            else if(playerid==1) swal("Ooops " + name, "You missed your chance.You have 1 minute for each turn.Try to move little bit faster on next move.", "error");
            movedone(true);
    } else {
        prgwidth += 0.10;
        documentelemId["prgcolor"].style.width = prgwidth + '%';
    }
}

function stopcountdown() {
    if (timerId != 0) {
        clearInterval(timerId);
        prgwidth = 0;
        timerId = 0;
    }
}

function quitgame(){
    let lblink="https://chokosta.herokuapp.com/";
    location.reload(lblink);
  }
function moveghuti(ply, idx) {
    
    //console.log(pending,ply,playerid,currentscore);
    let winner=gamewin(ply);
    if(gamewin(ply))
    {
        

    return 0;
    }
    stopcountdown();
    if (pending && ply == playerid && currentscore) {
        let mapidx = ghutipos[ply][idx] + currentscore;
        if (mapidx < 25) {
            if (checkkatakuti(ply, idx, mapidx)) 
            {
                movedone(false);
            }
            else if (currentscore == 8 || currentscore == 4) 
            movedone(false);
            else movedone(true);
            
            
        } else {
            swal("Invalid move " + name, "You can't move this ghuti", "error");
        }
    } else {
        swal("Invalid move " + name, "You can't move this ghuti", "error");
    }
    return 0;
}


function checkkatakuti(ply1, idx, mapidx) {
    let boxno = playermap[ply1][ghutipos[ply1][idx]];
    let destboxno = playermap[ply1][mapidx];
    let ply1id = "p" + ply1 + "g" + idx;
    boxes.push(boxno);
    boxes.push(destboxno);
    let delidx = pos[boxno].indexOf(ply1id);
    if (delidx > -1) pos[boxno].splice(delidx, 1);
    if (notsafe[destboxno] && pos[destboxno].length == 1 && ply1 != parseInt(pos[destboxno][0].charAt(1))) {
        let ply2id = pos[destboxno][0];
        let ply2 = parseInt(ply2id.charAt(1)),
            idx2 = parseInt(ply2id.charAt(3));
        pos[destboxno] = [];
        ghutipos[ply2][idx2] = 0;
        pos[playermap[ply2][0]].push(ply2id);
        ghutipos[ply1][idx] += currentscore;
        pos[destboxno].push(ply1id);
        boxes.push(playermap[ply2][0]);
        pending = false;
        return true;
    } else {
        pos[destboxno].push(ply1id);
        ghutipos[ply1][idx] += currentscore;
        pending = false;
        return false;
    }
}

function moveghutiIsPossible(ply) {
    let notposible = true;
    if(currentscore==0)
    return 0;
    for (let i = 1; i < 5; i++) {
        if (ghutipos[ply][i] + currentscore <= 24) {
            notposible = false;
            return i;
        }
    }
    if (notposible) {
        pending = false;
        stopcountdown();
        let x = 1;
        if (ply == 1) x = 3;
        playbtn.innerText = "wait for " + playername[x] + "'s move";;
        playbtn.style.color = playercolor[x];
        playbtn.style.backgroundColor = "white";
        if (currentscore == 4 || currentscore == 8) {
            
            if(playerid==1 && tut)
            swal(currentscore + " But no valid move exists", "Try again!!!", "error");
            movedone(false);
        } else {
            if(playerid==1 && tut)
            swal("ooops! No valid move exists", "Better luck next time!!!", "error");
            movedone(true);
        }
        currentscore = 0;
    }
    return 0;
}

function chat() {
	let lblink=window.location.href;
            location.assign(lblink);
   
}


function compgoodmove(ply) {
    //currentscore=1;
    var idx = 0, safeghutimv = 0, bstmv = 0,bstgn=0, attackghutimv = 0,attackgn=0,mx=0,winmove=0,dist=0,bdmv=0,mnloss=0;
    for (var i = 1; i < 5; i++) {
        let curridx=ghutipos[ply][i];
        let destidx=ghutipos[ply][i]+currentscore;
        let realidx=playermap[ply][destidx];
        let currnotsafe=notsafe[playermap[ply][curridx]];
        if(pos[playermap[ply][curridx]].length>1)
        currnotsafe=false;
        let destnotsafe=notsafe[playermap[ply][destidx]];
        
        //console.log(curridx,destidx,realidx);
        if(ghutipos[ply][i] +currentscore<=24)
        {
            if(pos[realidx].length>1)
            destnotsafe=false;
            if(destidx==24)
            winmove=i;
            if( currnotsafe && destnotsafe && pos[realidx].length==1 && 
                parseInt(pos[realidx][0].charAt(1))!=ply && bstgn<profit[realidx])
            {
                bstmv=i;
                bstgn=destidx;
            }
            else if ( destnotsafe && pos[realidx].length==1 && parseInt(pos[realidx][0].charAt(1))!=ply && attackgn <profit[realidx])
            {
                attackgn=profit[realidx];
                attackghutimv= i;
            }
            if(currnotsafe && (!destnotsafe) && mx < destidx){
                    safeghutimv=i; mx=destidx;
                }
            if(currnotsafe && destnotsafe && mx <= 2*destidx && pos[realidx].length>1 && parseInt(pos[realidx][0].charAt(1))==ply){
                        safeghutimv=i;
                        mx=destidx;
            }
            if(safeghutimv==0 && (!destnotsafe))
            safeghutimv=i;
            let currdist=25;
            

            //profit[key]=val key is realboxidx val p1idx
            // realidx box reach step 
            // curridx in p1idx
            for(let j=1;j<5;j++){
                if(currdist>profit[realidx]-ghutipos[1][j] && profit[realidx]-ghutipos[1][j]>=0)
                currdist=profit[realidx]-ghutipos[1][j];
            }
            
            if(currnotsafe && dist<currdist){
                idx=i;
                dist=currdist;
            }
            else if(currnotsafe && dist==currdist){
                if(ghutipos[ply][idx]>destidx)
                idx=i;
            }
            if(!currnotsafe && mnloss<currdist){
                mnloss=currdist;
                bdmv=i;
            }
            else if(!currnotsafe && mnloss==currdist){
                if(ghutipos[ply][mnloss]>currdist)
                bdmv=i;
            }
           console.log("distance="+currdist,"\nfrom unsafe=",idx,dist,currnotsafe+"\n",bdmv,mnloss);
            
        }
    }
    console.log("score=",currentscore)
    if(bstmv && bstgn+3>attackgn)
        return bstmv;
    else if (attackghutimv)
        return attackghutimv;
    else if(winmove)
        return winmove;
    else if(safeghutimv)
        return safeghutimv;
    else if(idx)
        return idx;
    else if(bdmv)
        return bdmv;
    return 0;
}